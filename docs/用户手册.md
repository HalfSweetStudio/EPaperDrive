# 用户手册
本手册为该驱动库的用户手册，让用户对如何使用该驱动库有个大概的了解。

## 将驱动库进行实例化并进行一些初始化操作
将该驱动库进行实例化的时候，其构造函数有如下几个构造参数：`SPIMode` `CS` `RST` `DC` `BUSY` `CLK` `DIN` 。其中SPIMode用于选择使用硬件SPI还是软件SPI，当其为0的时候为软件SPI；当其为1的时候为硬件SPI。其余的参数均为对应连接的引脚，值得注意的是，如果您打算采用硬件SPI的方式驱动，您可以不用填`CLK`与`DIN`的参数，留空即可。

## 选择硬件SPI还是软件SPI
当您看到构造函数中可选硬件SPI以及软件SPI的时候，您也许会有些困惑，不知道应当如何选择。实际上，除了引脚冲突或者是别的原因导致您无法使用硬件SPI之外，我都诚恳地建议您采用硬件SPI来驱动。以常见的ESP8266为例，如果采用软件SPI，不仅频率难以控制，并且其最大速率并不会超过500kHz。但是如果您采用硬件SPI，那您可以轻松达到大部分驱动芯片的速率上限：20MHz，这样可以大大为您节省不少本不应该被浪费的时间。  
不过需要注意的是，如果您采用的硬件SPI，请您先主动初始化SPI并调用`SetHardSPI`函数来将实际的硬件SPI指针传入，以便驱动库进行下一步操作。如果您没有看懂这一步，请参阅[HardSPIHelloWorld](../examples/HardSPIHelloWorld/HardSPIHelloWorld.ino)例程来查看

## 传入对应的文件系统指针以使用字库
您可以在例程中注意到，在我们对墨水屏进行任何操作之前，往往都会调用一个名为`SetFS`的函数，这个函数的作用便是将您喜欢的文件系统传入。需要注意的是，您在传入之前请先将您使用的文件系统初始化，例如`LittleFS.begin()`；并将对应的字库文件上传（字库文件在每个例程及驱动库的根目录下的data文件夹中）。

## 墨水屏的驱动步骤
首先，当您是第一次上电的时候，您需要至少进行一次全刷，之后才可以继续进行全刷或者是局刷的操作。  
想要全刷的话，您仅仅需要调用`EPD_init_Full()`函数进行全刷的初始化，然后利用别的绘图函数在图像缓存中进行绘图。当您绘图结束之后，您可以调用`EPD_Dis_Full(uint8_t *DisBuffer, uint8_t Label)`函数来将绘图完成的缓存传入驱动芯片并且开始全刷。别忘了，在刷屏结束之后调用`deepsleep()`函数来使墨水屏进入休眠模式，这不仅利于您降低功耗，同时也可以避免墨水屏出现颜色逐渐变浅的情况。

## 如何显示图片？
想要在墨水屏上显示一些图片，也许是个不错的主意。令人兴奋的是，我们提供了一系列的API供您完成您绝妙的创意。您可以调用`drawXbm`与`DrawXbm_P`函数来向缓存中绘入您所期望的图片。这两个函数的区别在于`DrawXbm_P`绘制的是您采用PROGMEM类型存储的图像，这会将数据存储在flash而不是RAM，相信您会喜欢上这一点。  
也许您会有这样的疑问，如何将.jpg等拓展名的图像转换为可识别的数据呢？非常简单，只需要使用任意一款图像取模软件（我喜欢用Image2lcd，虽然它很古老，但是依旧能完美地完成任务），使用单色模式垂直扫描将其转换为一连串的c数组即可。

## 制作自己的字体
您可以使用[FontMaker](https://gitee.com/kerndev/FontMaker)软件来生成自己的字库，使用该软件生成垂直扫描、高位在前，标准字库为ASCII或者Unicode的bin文件字库，并调用`SetFont()`函数进行定义文件路径和宽高。